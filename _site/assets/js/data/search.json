[
  
  {
    "title": "Hacking Forager ‚Äî Part 1: DLL Injection (A Fun, Technical Deep Dive)",
    "url": "/posts/Hacking-Forager-1/",
    "categories": "gamehacking, low-level",
    "tags": "dllinjection",
    "date": "2025-11-25 00:00:00 +0200",
    





    
    "snippet": "Hey everyone!Welcome to the first entry of my multi-part series on hacking Forager ‚Äî a wonderfully addictive 2D open-world crafting game by HopFrog.(And if you haven‚Äôt already played it, you can fi...",
    "content": "Hey everyone!Welcome to the first entry of my multi-part series on hacking Forager ‚Äî a wonderfully addictive 2D open-world crafting game by HopFrog.(And if you haven‚Äôt already played it, you can find it on steam. ‚Üí Forager on Steam)Forager throws you into a fast-paced loop of gathering, crafting, building and fighting. It‚Äôs simple on the surface but has a surprising amount of depth when you get into it.And today, we‚Äôre going to completely trivialize all of that with a cheat menu of my own creation, I‚Äôm very excited to be writing about this project as it contains some of my favorite subjects such as DLL Injections, low level code patching and messing with process memory for advantages in game!This series will come in four parts:1 ‚Äî DLL Injection  ‚Üê you are here2 - ImGui Implementation of a simple overlay3 ‚Äî Accessing Process Memory via Static Pointers4 ‚Äî Patching Game Behavior Manually (Code Injection)Alright, enough intro ‚Äî let‚Äôs talk DLLs.What‚Äôs a DLL, Really?A DLL (Dynamic-Link Library) is essentially a collection of functions and code that can be easily accessed, regardless of language. Programs rely on DLLs for extra functions, shared code, and system-level features.For example:  kernel32.dll handles things like CreateProcess  user32.dll handles things like keyboard input &amp; cursor positionWhile many programming languages provide APIs that abstract these calls, under the hood they call DLLs that are windows / kernel managed to provide us with basic features such as opening a process or getting user input.Just like EXEs, DLLs have an entry point ‚Äî DllMain ‚Äî which runs when the DLL is loaded into a process.We won‚Äôt be exporting custom functions in this series, but we will be using DLLs to run code inside the game.What Is DLL Injection?DLL injection is the act of forcing another process to load your DLL, even though it normally never would.The key idea:  If your DLL loads inside the game‚Äôs memory, your code runs with the game‚Äôs permissions and can read, write, and execute anything the game can.That‚Äôs why DLL injection has alot of uses in:  cheat menus  internal overlays  game modding  debugging tools  trainersAnd yes ‚Äî any decent anti-cheat will detect this method easily.It‚Äôs also important to note that Forager is a single-player game with a modding API, I won‚Äôt be ruining anyone else‚Äôs experience with this project.The Game PlanHere‚Äôs the exact workflow we‚Äôll be implementing:  Write a test DLL to confirm the injection  Find the target process (Forager.exe) and get a handle to it  Allocate memory inside the game for the path of our DLL  Write our DLL path into that memory  Call LoadLibraryA from within the game using CreateRemoteThreadThis might look a tad scary for those who‚Äôve not worked with DLLs, but once you‚Äôve seen it once, you‚Äôll realize it‚Äôs pretty straightforward. The only scary part about this is going to be the Windows API Naming Scheme, legacy code has it‚Äôs weaknesses and that‚Äôs the most glaring one.Step 1 ‚Äî Building a Test DLL#include &lt;windows.h&gt;DWORD WINAPI MainThread(LPVOID lpParam) {    MessageBoxA(NULL, \"DLL Injection!\", \"DLL Injection!\", NULL);    return 0;}BOOL APIENTRY DllMain(HMODULE hModule,    DWORD ul_reason_for_call,    LPVOID lpReserved) {    switch (ul_reason_for_call) {    case DLL_PROCESS_ATTACH:        CreateThread(NULL, NULL, MainThread, NULL, NULL, NULL);        break;    }    return TRUE;}If you‚Äôve never seen a DLL before, this probably looks like alien syntax, but here‚Äôs the TL;DR:DllMain(hModule, reason, lpReserved)  hModule ‚Üí the base address of our DLL in the target process  reason ‚Üí tells you why the DLL is being called (we only care about DLL_PROCESS_ATTACH)  lpReserved ‚Üí we can safely ignore this argument.if you‚Äôre wondering why we‚Äôre creating a new thread - because our DLL will eventually run a GUI and some logic loops, we don‚Äôt want to block the game‚Äôs main thread, otherwise Forager freezes every time you do something as our actions will block main thread activity.Creating a separate thread is standard practice for cheat menus.Step 2 ‚Äî Preparing the InjectorFull source here.Before we do anything fancy, we enable debug privileges:bool enableDebugPrivilege() {    HANDLE hToken = nullptr;    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &amp;hToken))        return false;    TOKEN_PRIVILEGES tp;    LUID luid;    if (!LookupPrivilegeValue(nullptr, SE_DEBUG_NAME, &amp;luid)) {        CloseHandle(hToken);        return false;    }    tp.PrivilegeCount = 1;    tp.Privileges[0].Luid = luid;    tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;    BOOL ok = AdjustTokenPrivileges(hToken, FALSE, &amp;tp, sizeof(tp), nullptr, nullptr);    CloseHandle(hToken);    return ok &amp;&amp; GetLastError() == ERROR_SUCCESS;}Short Windows Internals TangentWithout this privilege enabled on our process, some processes simply won‚Äôt allow remote thread creation or memory operations from testing.SeDebugPrivilege allows a process to inspect and modify other processes regardless of ownership of that process. Windows stores privileges inside access tokens, every  process has one. Similarly to usage of JWTs in modern web apps, it contains information of who you are and what you‚Äôre allowed to do.Even when running as administrator you must explicitly turn this privilege on. When requesting permission from the OS to get this privilege, it will check our access token to determine if an administrator ran the program, which is why we have to run the injector as administrator to get access to this privilege.While this knowledge is not absolutely neccessary to understand the injector, I think it‚Äôs important to understand this part as these topics become very relevant very quickly when dealing with an anti-cheat or any defensive system such as Anti Virus programs that we bypass in the pentesting world.Step 3 ‚Äî Finding the Forager ProcessSimple process enumeration:vector&lt;PROCESSENTRY32&gt; listProcesses(){    vector&lt;PROCESSENTRY32&gt; list;    HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);    if (snapshot == INVALID_HANDLE_VALUE) return list;    PROCESSENTRY32 pe;    pe.dwSize = sizeof(pe);    if (Process32First(snapshot, &amp;pe))    {        do {            list.push_back(pe);        } while (Process32Next(snapshot, &amp;pe));    }    CloseHandle(snapshot);    return list;}Then filter:PROCESSENTRY32W foragerProcEntry{0};bool found = false;for (auto&amp; proc : processes){    string currExe = WCharToStr(proc.szExeFile);    if (currExe == TARGETEXE) // TARGETEXE = \"Forager.exe\"    {        foragerProcEntry = proc;        found = true;    }}Step 4 ‚Äî Opening the ProcessHANDLE hForager = OpenProcess(    PROCESS_CREATE_THREAD |    PROCESS_QUERY_INFORMATION |    PROCESS_VM_OPERATION |    PROCESS_VM_WRITE |    PROCESS_VM_READ,    FALSE,    foragerProcEntry.th32ProcessID);We need:  VM read/write  ability to allocate memory  ability to create a thread inside the gameStep 5 ‚Äî Allocating Memory for the DLL PathThis is the part that‚Äôs most prone to confusion:auto strLen = MENUDLL.size() + 1; // +1 for null terminatorauto memRegion = VirtualAllocEx(hForager, NULL, strLen, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);WriteProcessMemory(hForager, memRegion, MENUDLL.c_str(), strLen, NULL);Adding 1 to the MENUDLL sizeMENUDLL is a const std::string, LoadLibraryA expects a c-style string, which means a null terminated string. std::string does not include null termination in it‚Äôs size and we must make sure the null termination is there otherwise the program could be reading any data that happens to be in that memory region until a null byte appears, thereby making our DLL path corrupted with random data.When allocating adding space for the null byte insures that when we call MENUDLL.c_str(), the entire string, null byte included gets written in the game memory.Why are we allocating memory inside the game?When we call LoadLibraryA remotely, it runs inside Forager‚Äôs memory space ‚Äî not our injector process.So the string pointer we pass must refer to memory that exists inside Forager.The injector and the game do not share address spaces.This also means that the string we pass it in my case is an absolute path and not a relative one, if you want to pass in a relative path you must make sure it‚Äôs within the same folder as the game executable or within one of the standard search locations for windows, you can check the standard search order here.Step 6 ‚Äî Calling LoadLibraryA Inside the Game// grab the LoadLibraryA addressauto loadLibraryAddr =    GetProcAddress(GetModuleHandleA(\"kernel32.dll\"), \"LoadLibraryA\");// execute LoadLibraryA with our custom DLL as the argumentauto injectedThreadHandle = CreateRemoteThread(    hForager,    NULL,    0,    (LPTHREAD_START_ROUTINE)loadLibraryAddr,    memRegion,    0,    NULL);And just like that:Forager loads the DLL and our DllMain executes.Step 7 ‚Äî Checking Injection SuccessWaitForSingleObject(injectedThreadHandle, 5000);DWORD exitcode = 0;GetExitCodeThread(injectedThreadHandle, &amp;exitcode);if (exitcode != 0) {    cout &lt;&lt; \"Thread handle: 0x\" &lt;&lt; hex &lt;&lt; injectedThreadHandle &lt;&lt; endl;    cout &lt;&lt; \"Allocated memory at: 0x\" &lt;&lt; hex &lt;&lt; memRegion &lt;&lt; endl;    cout &lt;&lt; \"Successfully injected the DLL.\" &lt;&lt; endl;    VirtualFreeEx(hForager, memRegion, 0, MEM_RELEASE);    CloseHandle(injectedThreadHandle);    CloseHandle(hForager);}else {    cout &lt;&lt; \"Failed to inject DLL, exit code: {\" &lt;&lt; exitcode &lt;&lt; \"}.\" &lt;&lt; endl;}This part of the code is a fail check that checks if our DLL was injected correctly, while we can rely on a message box which (spoiler alert!) does pop up after the injection happens, when developing our GUI, we don‚Äôt want to rely on that to confirm injection.We can grab the exit code using GetExitCodeThread to make sure our DLL was loaded. It‚Äôs return value is going to be the HMODULE of the injected DLL, or in non-windows terms, we get an address (a pointer) to the base of the DLL that was just loaded relative to Forager‚Äôs memory space.If the injection fails, it will return NULL, a.k.a the value 0.Important Project SettingsSubsystem ‚Üí Windows (/SUBSYSTEM:WINDOWS)Configuration Type ‚Üí Dynamic Library (.dll)Injection Success üéâThe DLL message box confirms it:Our code is officially running inside Forager.From here, we‚Äôll be able to:  read game memory  write to game memory  hook functions  build GUI overlays  patch game logic manuallyThis sets us up perfectly for Part 2: ImGui Implementation of a simple overlay.Thanks for reading ‚Äî Part 2 drops soon!"
  }
  
]

